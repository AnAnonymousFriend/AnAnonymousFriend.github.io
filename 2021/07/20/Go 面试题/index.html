<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Kai">





<title>Go 面试题 | 面向兴趣编程</title>



    <link rel="icon" href="/icoimage.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">anonymity&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">anonymity&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Go 面试题</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Kai</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 20, 2021&nbsp;&nbsp;22:23:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Go/">Go</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="切片的初始化"><a href="#切片的初始化" class="headerlink" title="切片的初始化"></a>切片的初始化</h2><p>切片的初始化包括三种：</p>
<p><strong>使用下标</strong> arr[0:3] or slice[0:3]</p>
<p>它是所有方法中最底层的一种，使用下表初始化切片不会复制原数组或原切片中的数据，只会创建一个指向原数组的切片结构体，<strong>所以修改新切片的数据也会修改原切片。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	arrOne := arr[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	arr[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">	fmt.Println(arrOne)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ [<span class="number">1</span> <span class="number">4</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<p><strong>字面量</strong> slice :&#x3D; []int{1,2,3}  </p>
<p>使用字面量，大部分工作会在编译期间完成。</p>
<p><strong>关键字</strong> slice :&#x3D; make([]int,10,10)</p>
<p>使用 make 关键字时，很多工作需要运行时的参与，调用方必须向 make 函数传入切片的大小及可选容量，这是为了确保</p>
<p>1.切片的大小和容量是否足够小</p>
<p>2.切片是否发生了逃逸，最终在堆中初始化。</p>
<p>如果切片非常大，运行时会直接在堆上初始化，如果切片不会发生逃逸并且非常小，例如小于等于4个元素，则直接在栈上或静态存储区创建数组。</p>
<blockquote>
<p>大于32 KB 的对象会在堆中初始化。</p>
</blockquote>
<h2 id="Go-语言中-new-和-make-的区别"><a href="#Go-语言中-new-和-make-的区别" class="headerlink" title="Go 语言中 new 和 make 的区别"></a><strong>Go 语言中 new 和 make 的区别</strong></h2><p>new 和 make 都是 分配内存的原语。new 只分配内存但并不初始化内存，而 make 用于 slice , map 和 channel 的初始化。</p>
<p>slice , map , channel 类型属于引用类型，go 会给引用类型初始化为 nil , 所以 make 不仅可以开辟一个内存，还能给找个内存的类型初始化其零值。</p>
<p>make 只能用来分配及初始化类型为 slice, map , channel 的数据。new 可以分配任意类型的数据。</p>
<p>make 返回的还是引用类型本身；而 new 返回的是指向类型的指针。</p>
<h2 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a><strong>数组和切片的区别</strong></h2><p>数组类型的值的长度必须在声明的时候给定，并且之后不会再改变。</p>
<p>切片可以自动扩容，我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<p><strong>切片引入了一个抽象层，提供了对数组中部分连续的片段引用，</strong></p>
<h2 id="数组相比切片有什么优势"><a href="#数组相比切片有什么优势" class="headerlink" title="数组相比切片有什么优势"></a><strong>数组相比切片有什么优势</strong></h2><p><strong>可比较</strong>：数组是固定长度，它们之间是可以比较的，数组是<strong>值对象</strong>。切片不可以直接比较，也不能用于判断。数组可以作为 map 的 <strong>键</strong>（key）, 而切片不行。</p>
<p><strong>编译安全</strong>：数组可以提供更高的编译时安全，可以在编译时检查索引范围。</p>
<p><strong>规划内存布局</strong>：更好控制内存布局，因为不能直接在带有切片的结构中分配空间，所以可以使用数组来解决。</p>
<p><strong>访问速度</strong>：其访问（单个）数组元素比访问切片元素更高效，时间复杂度是 O (1)</p>
<p>更多细节：<a target="_blank" rel="noopener" href="https://eddycjy.com/posts/go/go-array-slice/">https://eddycjy.com/posts/go/go-array-slice/</a></p>
<h2 id="切片会输出什么结果？"><a href="#切片会输出什么结果？" class="headerlink" title="切片会输出什么结果？"></a>切片会输出什么结果？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">	doWork(data)</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(data []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	data = <span class="built_in">append</span>(data, <span class="number">1</span>)</span><br><span class="line">	data[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意两个点：</p>
<p>1.Go 语言函数传值，<strong>无论是传递基本类型，结构体还是指针，都会对传递的参数进行拷贝。</strong></p>
<p>2.切片的扩容机制</p>
<p>这里可以先看一下切片的数据结构:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从切片的数据结构可以看出，Data 是一个内置的指针类型，可直接更改引用地址的参数。所以虽然函数使用值传递，但是在函数内部执行 date[0] &#x3D; 1 ，外部的切片数据也会发生变化。</p>
<p>但是 Len 和 Cap 是 int 类型，这代表，函数内部更改不会影响到函数外的数据源。</p>
<p>回到题目本身，data 初始化后是 [0,0,0] 值传递到 doWork 函数后进行扩容，数据发生变化 data 为 [0,0,0,0] 后修改切片的第一个元素 [1,0,0,0]，但是这是在 doWork 函数中内的数据变化，并不会影响到 main 函数中 data 的值。</p>
<p>切片的扩容是为切片分配新的内存空间并复制原切片中元素的过程。如果切片中的元素不是指针类型，那么会将原数组内存中的内容复制到新申请的内容中，这将最终会返回一个新切片，并覆盖原切片。</p>
<blockquote>
<p>所以在使用 append 函数对切片进行扩容后，需要一个变量去接受它的新切片。</p>
</blockquote>
<blockquote>
<p><strong>遇到大切片扩容或复制的时候，可能会引发大规模的内存复制，一定要减少类似的操作以避免影响程序的性能。</strong></p>
</blockquote>
<h2 id="Map的线程安全"><a href="#Map的线程安全" class="headerlink" title="Map的线程安全"></a><strong>Map的线程安全</strong></h2><p>Go 内建的 map 对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致 panic 。</p>
<p>解决 Map 的线程安全有多个方案：1.互斥锁 2.读写锁 <a target="_blank" rel="noopener" href="http://3.sync.map/">3.Sync.Map</a> 4.分片加锁</p>
<p>前两个方案不用过多赘述，可以重点谈论一下后两个方案。</p>
<p>Go 内建的 map 类型不是线程安全的，而 <a target="_blank" rel="noopener" href="http://sync.map/">Sync.Map</a> 并不是来替换内建的 map 类型的，它只能被应用在一些特殊场景内</p>
<p>1.只会增长的缓存系统中，一个 key 只写入一次而被读很多次。</p>
<p>2.多个 goroutine 为不相交的键读，写 和 重写键值对。</p>
<p>优点：</p>
<p>1.空间换时间。通过冗余的两个数据结构（只读的 read 字段，可写的 dirty ）,来减少加锁对性能的影响。对只读字段（read）的操作不需要加锁。</p>
<p>2.优先从 read 字段读取，更新，删除，因为对read字段的读取不需要锁。</p>
<p>3.动态调整。miss 次数过多，将 dirty 数据提升为read，避免总是从 dirty 中加锁读取。</p>
<p>4.double-checking。加锁之后还要再检查 read 字段，确定真的不存在才操作 dirty 字段。</p>
<p>5.延迟删除。删除一个键值只是打标记，只有在提升dirty 字段为 read 字段的时候才清理删除的数据。</p>
<p><strong>分片加锁 可看</strong>：<a target="_blank" rel="noopener" href="https://github.com/orcaman/concurrent-map">https://github.com/orcaman/concurrent-map</a></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串 与 切片的结构体相比，字符串只少了一个表示容量的 Cap 字段。在谈论切片的时候我们提到过一个代码例子，稍微更改代码示例后</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data = <span class="string">&quot;123&quot;</span></span><br><span class="line">	doWork(data)</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(data <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	data = <span class="string">&quot;99&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码并不会按照切片代码逻辑执行，不会输出 “99”，而是依然输出 “123”。这是因为 <strong>字符串虽然和切片的结构体高度相似，但是字符串是一个只读的切片类型。所有在字符串上的写入操作都是通过拷贝实现的。</strong></p>
<p><strong>这种不可变的特性可以保证我们不会引用到意外发生改变的值，而因为 Go 语言的字符串可以作为哈希的键，所以如果哈希的键是可变的，不仅会增加哈希实现的复杂性，还可能会影响哈希的比较。</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>接口的本质是引入一个新的中间层，调用方通过接口与具体实现分离，解除上下游的耦合，上层模块不需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p>
<p>Go 语言中的接口有两种表达形式，一种是正常的接口类型，另外一种不包含任何方法的接口在实现时，使用了特殊的类型。</p>
<blockquote>
<p>interface{} 类型不是任意类型。如果将类型转换成了 interface{} 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 interface{}</p>
</blockquote>
<p><strong>Go 语言的接口类型不是任意类型，它很有可能向方法传入参数之后，变量的赋值，类型转换时，发生隐式的类型转换。</strong></p>
<p>Go 1.18 支持泛型后，Go interface 的意义已经彻底被改变了。<strong>旧接口定义了方法集合，现接口定义了类型集合。</strong></p>
<p>interface 的定义也扩展了。先前，接口定义只能包含方法元素（method element），现在的接口除了方法元素外，还可以包含类型元素。</p>
<p><strong>interface 包含的元素类型必须是底层类型，而且不能是接口类型。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IO <span class="keyword">interface</span> &#123;</span><br><span class="line">	~MyInt <span class="comment">// 错误，不能这样使用，只能是底层类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>联合（union） 类型元素不能是类型参数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误 interface 里面的 K 是类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I1</span> [<span class="title">K</span> <span class="title">any</span>, <span class="title">V</span> <span class="title">interface</span></span> &#123; K &#125;]()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误, interface&#123; nt | K &#125;中K 是类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I2</span>[<span class="title">K</span> <span class="title">any</span>, <span class="title">V</span> <span class="title">interface</span></span>&#123; <span class="type">int</span> | K &#125;]() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>联合类型元素的非接口元素必须是两两不相交</strong></p>
<p>比如 int | string 的交集是空集</p>
<p><strong>联合类型元素如果包含多余一个元素，不能包含非空方法的接口类型，也不能是 comparable 或者嵌入 comparable</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译没问题，只包含一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I9</span>[<span class="title">K</span> <span class="title">interface</span></span>&#123; io.Reader &#125;]() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误!不能编译。因为包含了两个元素，而且无论是`io.Reader`还是`io.Writer`都包含方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I10</span>[<span class="title">K</span> <span class="title">interface</span></span>&#123; io.Reader | io.Writer &#125;]() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译正常，因为这是正常的接口，没有联合元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I11</span>[<span class="title">K</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">	io.Reader</span><br><span class="line">	io.Writer</span><br><span class="line">&#125;]() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误! 联合类型多于一个元素，并且io.Reader包含方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I12</span>[<span class="title">K</span> <span class="title">interface</span></span>&#123; io.Reader | <span class="type">int</span> &#125;]() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且不能是comparable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I13</span>[<span class="title">K</span> <span class="title">comparable</span> | <span class="title">int</span>]<span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且元素不能嵌入comparable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I14</span>[<span class="title">K</span> <span class="title">interface</span></span>&#123; comparable &#125; | <span class="type">int</span>]() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h2><p>Go 语言中反射的第一法则：<strong>我们能将 Go 语言的 interface{} 变量转换成反射对象。因为函数的调用都是值传递，所以变量类型在底层函数调用时进行类型转换。所以会从基本类型转换到 interface{}</strong></p>
<p>第二法则：我们可以从反射对象获取 interface{} 变量。</p>
<p>第三法则：我们得到的反射对象跟原对象没有任何关系，那么直接修改反射对象无法改变原变量，程序为了防止错误就会崩溃。</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>同时有多个 case 就绪时 select 会<strong>随机</strong>选择一个 case 执行其中的代码，这是为了避免按照顺序执行，后面的条件永远得不到执行，引入随机性是为了避免饥饿问题发生。 </p>
<h2 id="panic-和-recover-关键字"><a href="#panic-和-recover-关键字" class="headerlink" title="panic 和 recover 关键字"></a><strong>panic 和 recover 关键字</strong></h2><p>panic 只会触发当前 Goroutine 的 defer</p>
<p>recover 只有在 defer 中调用才会生效</p>
<p>panic 允许在 defer 中嵌套多次调用</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a><strong>defer</strong></h2><p>使用 defer 最常见的场景是在函数调用结束后完成一些收尾工作，例如在 defer 中回滚数据库的事务。</p>
<p><strong>执行顺序</strong></p>
<p>一个函数中，多个 defer 的执行顺序为 “后进先出”，但是这里要注意，如果函数中包含 return ，会先执行 return ，再执行 defer 。如果函数中包含 <strong>panic</strong> 函数，那么会先执行 defer 函数，最后再执行 panic 函数。</p>
<p><strong>defer声明时会先计算确定参数的值，defer推迟执行的仅是其函数体。</strong></p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><strong>Channel</strong></h2><p>先从 Channel 读取数据的 Goroutine 会先接收到数据</p>
<p>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利</p>
<p>Channel 在运行时使用 runtime.hchan 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>   <span class="comment">// Channel 中的元素个数</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>   <span class="comment">// Channel 中的循环队列的长度</span></span><br><span class="line">	buf      unsafe.Pointer  <span class="comment">// Channel 的缓冲区数据指针</span></span><br><span class="line">	elemsize <span class="type">uint16</span> <span class="comment">// Channel 能够手法的元素大小  </span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// Channel 能够手法的元素类型</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// Channel 的发送操作处理到的位置       </span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// Channel 的接收操作处理到的位置</span></span><br><span class="line">	recvq    waitq  <span class="comment">// 存储当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表</span></span><br><span class="line">	sendq    waitq</span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel 是一个用于同步和通信的有锁队列。</p>
<blockquote>
<p>向一个已经关闭的 Channel 发送数据时，会报告错误并中止程序。 向一个已经关闭的 Channel （无缓存）读数据时，会读取到零值。 向一个已经关闭的 Channel （有缓存） 读取数据时，会读取通道里面的剩余值。剩余值读取完后会读到零值。</p>
</blockquote>
<p><strong>Goroutine 的泄露</strong></p>
<p>如果启动了一个 goroutine ，但是没有符合预期地退出，直到程序结束，此 goroutine 才退出，这种情况叫做 goroutine 泄露。</p>
<p>一般泄露是因为 Channel 操作阻塞导致整个 goroutine 一直阻塞等待或 goroutine 里有死循环。</p>
<blockquote>
<p>共享资源的并发访问使用传统并发原语 复杂的任务编排和消息传递使用 Channel 消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond 简单等待所有任务的完成用 WaitGroup ，也有 Channel 的推崇者用 Channel，都可以使用 需要和 Select 语句结合，使用 Channel 需要和超时配合时，使用 Channel 和 Context</p>
</blockquote>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>《Go 并发编程实战》</p>
<p>《Go语言高性能编程》</p>
<p>《Go 语言设计与实现》</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Kai</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://ananonymousfriend.github.io/2021/07/20/Go%20%E9%9D%A2%E8%AF%95%E9%A2%98/">https://ananonymousfriend.github.io/2021/07/20/Go%20%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Go/"># Go</a>
                    
                        <a href="/tags/%E9%9D%A2%E8%AF%95/"># 面试</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/">计算机基础知识笔记</a>
            
            
            <a class="next" rel="next" href="/2021/07/03/Kubernetes%20%E9%83%A8%E7%BD%B2/">Kubernetes 安装</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Kai | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>